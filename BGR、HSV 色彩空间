HSV颜色识别
首先解释：为什么不在BGR空间范围内寻找物体的颜色信息，而在HSV空间寻找？
因为BGR通道，并不能很好地反应出物体的具体颜色信息，而相对于BGR颜色空间，HSV空间能够非常直观的表达色彩的明暗，色调，以及颜色鲜艳程度，方便进行颜色之间的对比。
HSV色彩空间，更符合人们对颜色的描述----是什么颜色，颜色有多深，颜色有多亮。
H即Hue 色相 就是平时所说的，红、绿、、、
S即Saturation 饱和度，色彩的深浅度（0-100%）
V即Value 色调 色彩的亮度（0-100%）


当S=1 V=1 ,H所代表的任何颜色都称为纯色；
当S=0,即饱和度为0，颜色最浅，最浅被描述为灰色（灰色也有亮度，黑白也属于灰色），灰色的亮度由V决定，此时H无意义。
当V=0,即色调为0，颜色最暗，最暗被描述为黑色，因此此时H（无论什么颜色都为黑色）和S（无论什么深浅的颜色最暗都为黑色）均无意义。


BGR转HSV有两种方式：
直接使用opencv中的cvtColor 函数，并设置参数为CV_BGR2HSV，那么所得的H、S、V值得范围分别是[0,180) 、[0，255）、[0，255），而非[0，360]、[0，1]、[0，1] 。

另一种方式：我们在cvtColor 函数转换前先加一步——对像素的BGR进行归一化处理，然后再转到HSV时，得到的结果就与之前介绍的相同了。
例如Mat src=imread("test.jpg");
Mat bgr,hsv;
 src.convertTo(bgr,CV_32FC3,1.0/255.0);
然后再cvtColor(bgr,hsv,CV_BGR2HSV);
cout<<hsv<<endl;













